
'''
/* *******************                                                        */
/*! \file MarabouNetworkNNetExtensions.py
 ** \verbatim
 ** Top contributors (to current version):
 ** Alex Usvyatsov
 ** This file is part of the Marabou project.
 ** Copyright (c) 2017-2019 by the authors listed in the file AUTHORS
 ** in the top-level source directory) and their institutional affiliations.
 ** All rights reserved. See the file COPYING in the top-level source
 ** directory for licensing information.\endverbatim
 **
 ** \brief
 ** Implements several operations on objets of types MarabouNetworkNNet
 ** Main feature implemented here is splitting a network of type into two
 **
 ** [[ Add lengthier description here ]]
 **/
'''


from MarabouNetworkNNetExtended import *
from  MarabouNetworkNNet import *
import numpy as np

def splitList(list,l):
    return list[:l], list[l:]

'''
Takes one MarabouNetworkNNEt object and layer, and returns two MarabouNetworkNNet objects, generated by cutting the original network
after the given layer. Note that the input layer is considered layer 0.
'''

def splitNNet(marabou_nnet: MarabouNetworkNNet, layer: int):
        if (layer < 1) or (layer > marabou_nnet.numLayers):
                print("nothing to do")
                return(False)
        weights1, weights2 = splitList(marabou_nnet.weights, layer)
        biases1, biases2 = splitList(marabou_nnet.biases, layer)

        # layerSizes1, layerSizes2 = splitList(marabou_nnet.layerSizes,layer+1)
        # Chose not to implement the split here and compute later; creates problems.

        # print("layesizes = ",marabou_nnet.layerSizes)
        # print("layesizes1 = ",layerSizes1)
        # print("layesizes2 = ",layerSizes2)

        new_input_size = marabou_nnet.layerSizes[layer + 1]

        mins1 = marabou_nnet.inputMinimums[:]

        # print(mins1)

        maxs1 = marabou_nnet.inputMaximums[:]

        means1 = marabou_nnet.inputMeans[:]
        ranges1 = marabou_nnet.inputRanges[:]

        '''
        No normalization for the outputs of the first network
        '''
        means1[-1] = 0
        ranges1[-1] = 1

        '''
        The mins and maxs of the second input layer are taken to be the lower and the upper bounds of that layer,
        respectively
        '''

        # to implement!!!!
        
        #mins2,maxs2 = marabou_nnet.returnBounds(layer)

        maxs2 = [0]*new_input_size  # Change!
        mins2 = [0]*new_input_size  # Change!

        '''
        No normalization for the new input layer
        '''
        means2 = [0] * (new_input_size+1)
        ranges2 = [1] * (new_input_size+1)

        '''
        The mean and the range for the output for the second network are the mean and the range of 
        the original output
        '''
        means2[-1] = marabou_nnet.inputMeans[-1]
        ranges2[-1] = marabou_nnet.inputRanges[-1]

        # NOTE that these choices may affect the evaluations! One should be careful with applying normalization.

        marabou_nnet1 = MarabouNetworkNNetExtended()
        marabou_nnet2 = MarabouNetworkNNetExtended()

        marabou_nnet1.resetNetworkFromParameters(mins1, maxs1, means1, ranges1, weights1, biases1)
        marabou_nnet2.resetNetworkFromParameters(mins2, maxs2, means2, ranges2, weights2, biases2)


        return marabou_nnet1,marabou_nnet2


def createRandomInputsForNetwork(marabou_nnet: MarabouNetworkNNet):

        inputs = []
        for input_var in marabou_nnet.inputVars.flatten():
            assert marabou_nnet.upperBoundExists(input_var)
            assert marabou_nnet.lowerBoundExists(input_var)
            random_value = np.random.uniform(low=marabou_nnet.lowerBounds[input_var],
                                             high=marabou_nnet.upperBounds[input_var])
            inputs.append(random_value)
        return inputs

def computeRandomOutputs(marabou_nnet: MarabouNetworkNNet, N: int):
        output_set =[]
        for i in range(N):
            inputs = createRandomInputsForNetwork(marabou_nnet)


            layer_output = marabou_nnet.evaluateNetwork(inputs, normalize_inputs=False, normalize_outputs=False)
            output_set.append(layer_output)

        return output_set



def computeRandomOutputsToLayer(marabou_nnet: MarabouNetworkNNet,layer: int, N: int):
        output_set =[]
        for i in range(N):
            inputs = createRandomInputsForNetwork(marabou_nnet)


            layer_output = marabou_nnet.evaluateNetworkToLayer(inputs,last_layer=layer, normalize_inputs=False, normalize_outputs=False)
            output_set.append(layer_output)

        return output_set

